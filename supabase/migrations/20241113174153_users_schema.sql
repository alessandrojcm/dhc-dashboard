-- Enable required extensions
create extension if not exists "uuid-ossp";
/*
 * Role types enum
 */
create type role_type as enum (
    -- Super user roles
    'admin',
    'president',
    -- Committee roles
    'treasurer',
    'committee_coordinator',
    'sparring_coordinator',
    'workshop_coordinator',
    'beginners_coordinator',
    'quartermaster',
    'pr_manager',
    'volunteer_coordinator',
    'research_coordinator',
    'coach',
    -- Normal members
    'member'
    );

/*
 * Core tables
 */
-- User profiles
create table user_profiles
(
    id               uuid                     default gen_random_uuid() primary key,
    supabase_user_id uuid references auth.users (id) unique,
    first_name       text not null,
    last_name        text not null,
    is_active        boolean                  default true,
    medical_conditions text,
    created_at       timestamp with time zone default now(),
    updated_at       timestamp with time zone default now()
);

create table public.user_roles
(
    id      bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade not null,
    role    role_type                                    not null,
    unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';


-- Audit log
create table user_audit_log
(
    id         uuid                     default gen_random_uuid() primary key,
    user_id    uuid references auth.users (id),
    action     text not null,
    details    jsonb,
    ip_address text,
    created_at timestamp with time zone default now()
);

/*
 * Role checking functions
 */
-- Check if user has specific role
create or replace function has_role(uid uuid, required_role role_type)
    returns boolean as
$$
begin
    return exists (select 1
                   from public.user_roles
                   where user_roles.user_id = uid
                     and (
                       required_role = role
                       ));
end;
$$ language plpgsql security invoker
                    set search_path = '';

-- Check if user has any of the specified roles
create or replace function has_any_role(uid uuid, required_roles role_type[])
    returns boolean as
$$
begin
    return exists (select 1
                   from public.user_roles
                   where user_roles.user_id = uid
                     and (select role = any (required_roles)));
end;
$$ language plpgsql security definer
                    set search_path = '';

/*
 * Triggers
 */
-- Update updated_at timestamp
create or replace function update_updated_at_column()
    returns trigger as
$$
begin
    new.updated_at = now();
    return new;
end;
$$ language plpgsql set search_path = '';

create trigger update_user_profiles_updated_at
    before update
    on user_profiles
    for each row
execute function update_updated_at_column();

-- Log role changes
create or replace function log_role_change()
    returns trigger as
$$
begin
    if old.roles is distinct from new.roles then
        insert into user_audit_log (user_id, action, details)
        values (new.id,
                'role_update',
                jsonb_build_object(
                        'old_roles', old.roles,
                        'new_roles', new.roles,
                        'modified_by', auth.uid()
                ));
    end if;
    return new;
end;
$$ language plpgsql security invoker
                    set search_path = '';

/*
 * Auth guards
 */
create or replace function public.custom_access_token_hook(event jsonb) returns jsonb
    language plpgsql
as
$$
declare
    claims           jsonb;
    user_roles       public.role_type[];
    is_valid         bool;
    hook_instance_id uuid;
begin
    hook_instance_id := gen_random_uuid();
    -- Create one instance ID for the entire hook execution

    -- Log the start of hook execution
    insert into auth.audit_log_entries (instance_id,
                                        id,
                                        payload)
    values (hook_instance_id,
            gen_random_uuid(),
            jsonb_build_object(
                    'event', event,
                    'step', 'auth_hook_start'
            ));

    -- Check if user_id exists in the event
    if event ->> 'user_id' is null then
        insert into auth.audit_log_entries (instance_id,
                                            id,
                                            payload)
        values (hook_instance_id,
                gen_random_uuid(),
                jsonb_build_object(
                        'event', event,
                        'error', 'No user_id in event',
                        'step', 'auth_hook_error'
                ));

        return jsonb_build_object(
                'error', jsonb_build_object(
                        'http_code', 403,
                        'message', 'Invalid token data'
                         )
               );
    end if;

    if not is_valid then
        insert into auth.audit_log_entries (instance_id,
                                            id,
                                            payload)
        values (hook_instance_id,
                gen_random_uuid(),
                jsonb_build_object(
                        'event', event,
                        'error', 'User not found in profiles',
                        'step', 'auth_hook_error',
                        'detail', 'user_not_found'
                ));

        return jsonb_build_object(
                'error', jsonb_build_object(
                        'http_code', 403,
                        'message', 'User not registered in the system'
                         )
               );
    end if;

    -- Get user roles
    begin
        select array_agg(role)
        into user_roles
        from public.user_roles
        where user_id = (event ->> 'user_id')::uuid;

        insert into auth.audit_log_entries (instance_id,
                                            id,
                                            payload)
        values (hook_instance_id,
                gen_random_uuid(),
                jsonb_build_object(
                        'event', event,
                        'roles', user_roles,
                        'step', 'auth_hook_info',
                        'detail', 'roles_fetched'
                ));
    exception
        when others then
            insert into auth.audit_log_entries (instance_id,
                                                id,
                                                payload)
            values (hook_instance_id,
                    gen_random_uuid(),
                    jsonb_build_object(
                            'event', event,
                            'error', SQLERRM,
                            'step', 'auth_hook_error',
                            'detail', 'roles_fetch_failed'
                    ));

            return jsonb_build_object(
                    'error', jsonb_build_object(
                            'http_code', 403,
                            'message', 'Error fetching user roles'
                             )
                   );
    end;

    -- Handle claims
    begin
        claims := event -> 'claims';
        if claims is null then
            claims := '{}'::jsonb;
        end if;

        -- Ensure app_metadata exists
        if not claims ? 'app_metadata' then
            claims := jsonb_set(claims, '{app_metadata}', '{}'::jsonb);
        end if;

        -- Add roles to claims
        claims := jsonb_set(
                claims,
                '{app_metadata,roles}',
                coalesce(to_jsonb(user_roles), '[]'::jsonb)
                  );

        -- Update final event
        event := jsonb_set(event, '{claims}', claims);

        insert into auth.audit_log_entries (instance_id,
                                            id,
                                            payload)
        values (hook_instance_id,
                gen_random_uuid(),
                jsonb_build_object(
                        'event', event,
                        'final_claims', claims,
                        'step', 'auth_hook_success'
                ));

        return event;
    exception
        when others then
            insert into auth.audit_log_entries (instance_id,
                                                id,
                                                payload)
            values (hook_instance_id,
                    gen_random_uuid(),
                    jsonb_build_object(
                            'event', event,
                            'error', SQLERRM,
                            'step', 'auth_hook_error',
                            'detail', 'claims_processing_failed'
                    ));

            return jsonb_build_object(
                    'error', jsonb_build_object(
                            'http_code', 403,
                            'message', 'Error processing claims'
                             )
                   );
    end;
end;
$$;

grant usage on schema public to supabase_auth_admin;

grant execute
    on function public.custom_access_token_hook
    to supabase_auth_admin;

revoke execute
    on function public.custom_access_token_hook
    from authenticated, anon, public;

grant all
    on table public.user_roles
    to supabase_auth_admin;

revoke all
    on table public.user_roles
    from anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles
    as permissive for select
    to supabase_auth_admin
    using (true);

/*
 * RLS Policies
 */
-- Enable RLS
alter table user_profiles
    enable row level security;
alter table user_audit_log
    enable row level security;
alter table auth.users
    enable row level security;
alter table user_roles
    enable row level security;


-- User profile policies
create policy "Committee members can see al profiles"
    on user_profiles
    for select
    to authenticated
    using (
    (select has_any_role((select auth.uid()), array [
        'admin',
        'president',
        'treasurer',
        'committee_coordinator',
        'sparring_coordinator',
        'workshop_coordinator',
        'beginners_coordinator',
        'quartermaster',
        'pr_manager',
        'volunteer_coordinator',
        'research_coordinator'
        ]::role_type[]))
    );

create policy "Users can view their own profile"
    on user_profiles
    for select
    to authenticated
    using ((select auth.uid()) = user_profiles.supabase_user_id and (select user_profiles.is_active) is true);

create policy "Only admins and committee members can add profiles"
    on user_profiles
    for insert
    to authenticated
    with check (
    (select has_any_role((select auth.uid()), array ['admin', 'president', 'committee_coordinator']::role_type[]))
    );

create policy "Only admins, committee members and the user can delete profiles"
    on user_profiles
    for delete
    to authenticated
    using (
    (select has_any_role((select auth.uid()), array ['admin', 'president', 'committee_coordinator']::role_type[]))
        or supabase_user_id = (select auth.uid())
    );

create policy "Users can update their own basic info"
    on user_profiles
    for update
    to authenticated
    using (supabase_user_id = (select auth.uid()) and user_profiles.is_active = true);
-- Existing policy: Allow committee coordinators, presidents, and admins to add roles
-- Updated to restrict adding 'admin' role only to admins
CREATE POLICY "Committee coordinators can add roles"
    ON user_roles
    FOR INSERT
    TO authenticated
    WITH CHECK (
    (
        (select
             has_any_role((SELECT auth.uid()), ARRAY ['committee_coordinator', 'president', 'admin']::role_type[]) AND
             role <> 'admin')) OR (select (
                                              has_role((SELECT auth.uid()), 'admin') AND
                                              role = 'admin'
                                              ))
    );

-- Existing policy: Committee coordinators can update roles
CREATE POLICY "Committee coordinators can update roles"
    ON user_roles
    FOR UPDATE
    TO authenticated
    USING (
    (select has_any_role((SELECT auth.uid()), ARRAY ['committee_coordinator', 'president', 'admin']::role_type[]))
    );

-- Existing policy: Users, admin and president can see their own roles
CREATE POLICY "Users, admin and president can see their own roles"
    ON user_roles
    FOR SELECT
    TO authenticated
    USING (
    (SELECT auth.uid()) = user_roles.user_id OR
    (SELECT has_any_role((SELECT auth.uid()), ARRAY ['committee_coordinator', 'president', 'admin']::role_type[]))
    );

-- Audit log policies
create policy "Audit logs viewable by admins"
    on user_audit_log
    for select
    to authenticated
    using (
    (SELECT has_any_role((select auth.uid()), array ['admin', 'president', 'committee_coordinator']::role_type[]))
    );

/*
 * Indexes
 */
create index idx_user_audit_created_at on user_audit_log (created_at);
create index idx_user_role on user_roles using btree (role, user_id, id);

-- Enable required extensions
create extension if not exists "uuid-ossp";
/*
 * Role types enum
 */
create type role_type as enum (
    -- Super user roles
    'admin',
    'president',
    -- Committee roles
    'treasurer',
    'committee_coordinator',
    'sparring_coordinator',
    'workshop_coordinator',
    'beginners_coordinator',
    'quartermaster',
    'pr_manager',
    'volunteer_coordinator',
    'research_coordinator',
    'coach',
    -- Normal members
    'member'
    );

/*
 * Core tables
 */
-- User profiles
create table user_profiles
(
    id               uuid                     default gen_random_uuid() primary key,
    supabase_user_id uuid references auth.users (id) unique,
    first_name       text not null,
    last_name        text not null,
    is_active        boolean                  default true,
    medical_conditions text,
    created_at       timestamp with time zone default now(),
    updated_at       timestamp with time zone default now()
);

create table public.user_roles
(
    id      bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade not null,
    role    role_type                                    not null,
    unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';


-- Audit log
create table user_audit_log
(
    id         uuid                     default gen_random_uuid() primary key,
    user_id    uuid references auth.users (id),
    action     text not null,
    details    jsonb,
    ip_address text,
    created_at timestamp with time zone default now()
);

/*
 * Role checking functions
 */
-- Check if user has specific role
create or replace function has_role(uid uuid, required_role role_type)
    returns boolean as
$$
begin
    return exists (select 1
                   from public.user_roles
                   where user_roles.user_id = uid
                     and (
                       required_role = role
                       ));
end;
$$ language plpgsql security invoker
                    set search_path = '';

-- Check if user has any of the specified roles
create or replace function has_any_role(uid uuid, required_roles role_type[])
    returns boolean as
$$
begin
    return exists (select 1
                   from public.user_roles
                   where user_roles.user_id = uid
                     and (select role = any (required_roles)));
end;
$$ language plpgsql security definer
                    set search_path = '';

/*
 * Triggers
 */
-- Update updated_at timestamp
create or replace function update_updated_at_column()
    returns trigger as
$$
begin
    new.updated_at = now();
    return new;
end;
$$ language plpgsql set search_path = '';

create trigger update_user_profiles_updated_at
    before update
    on user_profiles
    for each row
execute function update_updated_at_column();

-- Log role changes
create or replace function log_role_change()
    returns trigger as
$$
begin
    if old.roles is distinct from new.roles then
        insert into user_audit_log (user_id, action, details)
        values (new.id,
                'role_update',
                jsonb_build_object(
                        'old_roles', old.roles,
                        'new_roles', new.roles,
                        'modified_by', auth.uid()
                ));
    end if;
    return new;
end;
$$ language plpgsql security invoker
                    set search_path = '';

/*
 * Auth guards
 */
create or replace function public.custom_access_token_hook(event jsonb) returns jsonb
    language plpgsql
as
$$
declare
    claims           jsonb;
    user_roles       public.role_type[];
    is_valid         bool;
begin
    -- Check if user_id exists in the event
    if event ->> 'user_id' is null then
        raise log 'Invalid token data: missing user_id';
        return jsonb_build_object(
            'error', jsonb_build_object(
                'http_code', 403,
                'message', 'Invalid token data'
            )
        );
    end if;

    -- Check if user exists in user_profiles
    select exists(
        select 1
        from public.user_profiles
        where supabase_user_id = (event ->> 'user_id')::uuid
    ) into is_valid;

    raise log 'Checking user profile existence: %', jsonb_build_object(
        'user_id', event ->> 'user_id',
        'exists', is_valid
    );

    if not is_valid then
        raise warning 'User not found in profiles: %', event ->> 'user_id';
        return jsonb_build_object(
            'error', jsonb_build_object(
                'http_code', 403,
                'message', 'User not registered in the system'
            )
        );
    end if;

    -- Get user roles
    begin
        select array_agg(role)
        into user_roles
        from public.user_roles
        where user_id = (event ->> 'user_id')::uuid;

        raise log 'User roles fetched: %', jsonb_build_object(
            'user_id', event ->> 'user_id',
            'roles', user_roles
        );
    exception
        when others then
            raise warning 'Error fetching user roles: %', SQLERRM;
            return jsonb_build_object(
                'error', jsonb_build_object(
                    'http_code', 403,
                    'message', 'Error fetching user roles'
                )
            );
    end;

    -- Handle claims
    begin
        claims := event -> 'claims';
        if claims is null then
            claims := '{}'::jsonb;
        end if;

        -- Ensure app_metadata exists
        if not claims ? 'app_metadata' then
            claims := jsonb_set(claims, '{app_metadata}', '{}'::jsonb);
        end if;

        -- Add roles to claims
        claims := jsonb_set(
                claims,
                '{app_metadata,roles}',
                coalesce(to_jsonb(user_roles), '[]'::jsonb)
                  );

        -- Update final event
        event := jsonb_set(event, '{claims}', claims);

        raise log 'Claims updated successfully: %', jsonb_build_object(
            'user_id', event ->> 'user_id',
            'final_claims', claims
        );

        return event;
    exception
        when others then
            raise warning 'Error processing claims: %', SQLERRM;
            return jsonb_build_object(
                'error', jsonb_build_object(
                    'http_code', 403,
                    'message', 'Error processing claims'
                )
            );
    end;
end;
$$;

grant usage on schema public to supabase_auth_admin;

grant all
    on table public.user_roles
    to supabase_auth_admin;

grant all
    on table public.user_profiles
    to supabase_auth_admin;

revoke all
    on table public.user_profiles
    from anon, public;

revoke all
    on table public.user_roles
    from anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles
    for select
    to supabase_auth_admin
    using (true);
    
create policy "Allow auth admin to read user profiles" ON public.user_profiles
    for select
    to supabase_auth_admin
    using (true);

/*
 * RLS Policies
 */
-- Enable RLS
alter table user_profiles
    enable row level security;
alter table user_audit_log
    enable row level security;
alter table auth.users
    enable row level security;
alter table user_roles
    enable row level security;

-- Grant service role access to user_profiles
grant all on user_profiles to service_role;

create policy "Service role can manage user profiles"
    on user_profiles
    for all
    to service_role
    using (true)
    with check (true);

-- User profile policies
create policy "Committee members can see al profiles"
    on user_profiles
    for select
    to authenticated
    using (
    (select has_any_role((select auth.uid()), array [
        'admin',
        'president',
        'treasurer',
        'committee_coordinator',
        'sparring_coordinator',
        'workshop_coordinator',
        'beginners_coordinator',
        'quartermaster',
        'pr_manager',
        'volunteer_coordinator',
        'research_coordinator'
        ]::role_type[]))
    );

create policy "Users can view their own profile"
    on user_profiles
    for select
    to authenticated
    using ((select auth.uid()) = user_profiles.supabase_user_id and (select user_profiles.is_active) is true);

create policy "Only admins and committee members can add profiles"
    on user_profiles
    for insert
    to authenticated
    with check (
    (select has_any_role((select auth.uid()), array ['admin', 'president', 'committee_coordinator']::role_type[]))
    );

create policy "Only admins, committee members and the user can delete profiles"
    on user_profiles
    for delete
    to authenticated
    using (
    (select has_any_role((select auth.uid()), array ['admin', 'president', 'committee_coordinator']::role_type[]))
        or supabase_user_id = (select auth.uid())
    );

create policy "Users can update their own basic info"
    on user_profiles
    for update
    to authenticated
    using (supabase_user_id = (select auth.uid()) and user_profiles.is_active = true);

create policy "Committee members can update user profiles"
    on user_profiles
    for update
    to authenticated
    using (
        (select has_any_role((select auth.uid()), array ['admin', 'president', 'committee_coordinator']::role_type[]))
    );

-- Existing policy: Allow committee coordinators, presidents, and admins to add roles
-- Updated to restrict adding 'admin' role only to admins
CREATE POLICY "Committee coordinators can add roles"
    ON user_roles
    FOR INSERT
    TO authenticated
    WITH CHECK (
    (
        (select
             has_any_role((SELECT auth.uid()), ARRAY ['committee_coordinator', 'president', 'admin']::role_type[]) AND
             role <> 'admin')) OR (select (
                                              has_role((SELECT auth.uid()), 'admin') AND
                                              role = 'admin'
                                              ))
    );

-- Existing policy: Committee coordinators can update roles
CREATE POLICY "Committee coordinators can update roles"
    ON user_roles
    FOR UPDATE
    TO authenticated
    USING (
    (select has_any_role((SELECT auth.uid()), ARRAY ['committee_coordinator', 'president', 'admin']::role_type[]))
    );

-- Existing policy: Users, admin and president can see their own roles
CREATE POLICY "Users, admin and president can see their own roles"
    ON user_roles
    FOR SELECT
    TO authenticated
    USING (
    (SELECT auth.uid()) = user_roles.user_id OR
    (SELECT has_any_role((SELECT auth.uid()), ARRAY ['committee_coordinator', 'president', 'admin']::role_type[]))
    );

CREATE POLICY "Service role can insert user_roles entries"
    on user_roles
    for insert
    to service_role
    with check (true);

-- Audit log policies
create policy "Audit logs viewable by admins"
    on user_audit_log
    for select
    to authenticated
    using (
    (SELECT has_any_role((select auth.uid()), array ['admin', 'president', 'committee_coordinator']::role_type[]))
    );

/*
 * Indexes
 */
create index idx_user_audit_created_at on user_audit_log (created_at);
create index idx_user_role on user_roles using btree (role, user_id, id);
